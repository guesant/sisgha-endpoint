import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { has, isNil, isUndefined, omit } from 'lodash';
import MeiliSearch from 'meilisearch';
import { AppContext } from 'src/app-context/AppContext';
import { parralelMap } from 'src/common/utils/parralel-map';
import { {{ pascalCase name }}DbEntity } from 'src/database/entities/{{ paramCase name }}.db.entity';
import { get{{ pascalCase name }}Repository } from 'src/database/repositories/{{ paramCase name }}.repository';
import { INDEX_{{ constantCase name }} } from 'src/meilisearch/constants/meilisearch-tokens';
import { MEILISEARCH_CLIENT } from 'src/meilisearch/constants/MEILISEARCH_CLIENT.const';
import { FindOneOptions } from 'typeorm';
import { {{ pascalCase name }}Type } from './{{ paramCase name }}.type';
import {
  ICreate{{ pascalCase name }}Input,
  IDelete{{ pascalCase name }}Input,
  IFind{{ pascalCase name }}ByIdInput,
  IList{{ pascalCase name }}Input,
  IUpdate{{ pascalCase name }}Input,
  List{{ pascalCase name }}ResultType,
} from './dtos';

@Injectable()
export class {{ pascalCase name }}Service {
  constructor(
    @Inject(MEILISEARCH_CLIENT)
    private meilisearchClient: MeiliSearch,
  ) {}

  async find{{ pascalCase name }}ById(
    appContext: AppContext,
    dto: IFind{{ pascalCase name }}ByIdInput,
    options?: FindOneOptions<{{ pascalCase name }}DbEntity>,
  ) {
    const { id } = dto;

    const target{{ pascalCase name }} = await appContext.databaseRun(
      async ({ entityManager }) => {
        const {{ camelCase name }}Repository = get{{ pascalCase name }}Repository(entityManager);

        return {{ camelCase name }}Repository.findOne({
          where: { id },
          select: ['id'],
        });
      },
    );

    if (!target{{ pascalCase name }}) {
      return null;
    }

    const {{ camelCase name }} = await appContext.databaseRun<{{ pascalCase name }}DbEntity>(
      async ({ entityManager }) => {
        const {{ camelCase name }}Repository = get{{ pascalCase name }}Repository(entityManager);

        return await {{ camelCase name }}Repository.findOneOrFail({
          where: { id: target{{ pascalCase name }}.id },
          select: ['id'],
          ...options,
        });
      },
    );

    return {{ camelCase name }};
  }

  async find{{ pascalCase name }}ByIdStrict(
    appContext: AppContext,
    dto: IFind{{ pascalCase name }}ByIdInput,
    options?: FindOneOptions<{{ pascalCase name }}DbEntity>,
  ) {
    const {{ camelCase name }} = await this.find{{ pascalCase name }}ById(appContext, dto, options);

    if (!{{ camelCase name }}) {
      throw new NotFoundException();
    }

    return {{ camelCase name }};
  }

  async find{{ pascalCase name }}ByIdStrictSimple(
    appContext: AppContext,
    {{ camelCase name }}Id: number,
  ): Promise<Pick<{{ pascalCase name }}DbEntity, 'id'>> {
    const {{ camelCase name }} = await this.find{{ pascalCase name }}ByIdStrict(appContext, {
      id: {{ camelCase name }}Id,
    });

    return {{ camelCase name }} as Pick<{{ pascalCase name }}DbEntity, 'id'>;
  }

  async list{{ pascalCase name }}(
    appContext: AppContext,
    dto: IList{{ pascalCase name }}Input,
  ): Promise<List{{ pascalCase name }}ResultType> {
    const { query, limit, offset } = dto;

    const meilisearchResult = await this.meilisearchClient
      .index(INDEX_{{ constantCase name }})
      .search<{{ pascalCase name }}Type>(query, { limit, offset });

    const items = await parralelMap(meilisearchResult.hits, async (hit) => {
      const id = hit.id;

      if (!isNil(id)) {
        const {{ camelCase name }} = await this.find{{ pascalCase name }}ById(appContext, {
          id: hit.id,
        });

        if ({{ camelCase name }}) {
          return {{ camelCase name }};
        }
      }

      return null;
    });

    const result: List{{ pascalCase name }}ResultType = {
      query: meilisearchResult.query,

      limit: meilisearchResult.limit,
      offset: meilisearchResult.offset,

      total: meilisearchResult.estimatedTotalHits,

      items: items,
    };

    return result;
  }

  async get{{ pascalCase name }}GenericField<K extends keyof {{ pascalCase name }}DbEntity>(
    appContext: AppContext,
  {{ camelCase name }}Id: number,
    field: K,
  ): Promise<{{ pascalCase name }}DbEntity[K]> {
    const {{ camelCase name }} = await this.find{{ pascalCase name }}ByIdStrict(
      appContext,
      { id: {{ camelCase name }}Id },
      { select: ['id', field] },
    );

    return <{{ pascalCase name }}DbEntity[K]>{{ camelCase name }}[field];
  }

  /*
  async get{{ pascalCase name }}GenericField(appContext: AppContext, {{ camelCase name }}Id: number) {
    return this.get{{ pascalCase name }}GenericField(appContext, {{ camelCase name }}Id, 'genericField');
  }
  */

  async create{{ pascalCase name }}(appContext: AppContext, dto: ICreate{{ pascalCase name }}Input) {
    const fieldsData = omit(dto, []);

    const {{ camelCase name }} = <{{ pascalCase name }}DbEntity>{ ...fieldsData };

    await appContext.databaseRun(async ({ entityManager }) => {
      const {{ camelCase name }}Repository = get{{ pascalCase name }}Repository(entityManager);

      await {{ camelCase name }}Repository.save({{ camelCase name }});

      return {{ camelCase name }};
    });

    return this.find{{ pascalCase name }}ByIdStrictSimple(appContext, {{ camelCase name }}.id);
  }

  async update{{ pascalCase name }}(appContext: AppContext, dto: IUpdate{{ pascalCase name }}Input) {
    const { id } = dto;

    const {{ camelCase name }} = await this.find{{ pascalCase name }}ByIdStrictSimple(appContext, id);

    const fieldsData = omit(dto, ['id']);

    const updated{{ pascalCase name }} = <{{ pascalCase name }}DbEntity>{ ...{{ camelCase name }}, ...fieldsData };

    await appContext.databaseRun(async ({ entityManager }) => {
      const {{ camelCase name }}Repository = get{{ pascalCase name }}Repository(entityManager);

      await {{ camelCase name }}Repository.update{{ pascalCase name }}(updated{{ pascalCase name }}, {{ camelCase name }}.id);

      return updated{{ pascalCase name }};
    });

    return this.find{{ pascalCase name }}ByIdStrictSimple(appContext, {{ camelCase name }}.id);
  }

  async delete{{ pascalCase name }}(appContext: AppContext, dto: IDelete{{ pascalCase name }}Input) {
    const {{ camelCase name }} = await this.find{{ pascalCase name }}ByIdStrictSimple(appContext, dto.id);

    return appContext.databaseRun(async ({ entityManager }) => {
      const {{ camelCase name }}Repository = get{{ pascalCase name }}Repository(entityManager);

      try {
        await {{ camelCase name }}Repository.delete({{ camelCase name }}.id);
        return true;
      } catch (error) {
        return false;
      }
    });
  }
}
